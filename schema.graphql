type AggregateUser {
  count: Int!
}

input AuthUserInput {
  login: String!
  password: String!
}

type AuthUserOutput {
  token: String!
  user: User!
}

type BatchPayload {
  count: Int!
}

scalar DateTime

type Mutation {
  registerUser(data: RegistrationUserInput!): AuthUserOutput
  authUser(data: AuthUserInput!): AuthUserOutput
  updateUser(data: UserUpdateInput!): User!
  createOneUser(data: UserCreateInput!): User!
  updateOneUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User!
  deleteOneUser(where: UserWhereUniqueInput!): User
  upsertOneUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User
  deleteManyUser(where: UserWhereInput): BatchPayload
  updateManyUser(where: UserWhereInput, data: UserUpdateManyMutationInput): BatchPayload
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  user: User
  findOneUser(where: UserWhereUniqueInput!): User
  findFirstUser(where: UserWhereInput, orderBy: [UserOrderByInput!], cursor: UserWhereUniqueInput, distinct: UserDistinctFieldEnum, skip: Int, take: Int): [User!]
  findManyUser(where: UserWhereInput, orderBy: [UserOrderByInput!], cursor: UserWhereUniqueInput, distinct: UserDistinctFieldEnum, skip: Int, take: Int): [User!]
  findManyUserCount(where: UserWhereInput, orderBy: [UserOrderByInput!], cursor: UserWhereUniqueInput, distinct: UserDistinctFieldEnum, skip: Int, take: Int): Int!
  aggregateUser(where: UserWhereInput, orderBy: [UserOrderByInput!], cursor: UserWhereUniqueInput, distinct: UserDistinctFieldEnum, skip: Int, take: Int): AggregateUser
}

enum QueryMode {
  default
  insensitive
}

input RegistrationUserInput {
  login: String!
  password: String!
  name: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

type User {
  id: String!
  login: String!
  name: String
  group: String
}

input UserCreateInput {
  id: String
  login: String!
  name: String
  group: String
  password: String!
}

enum UserDistinctFieldEnum {
  id
  login
  name
  group
  password
}

input UserOrderByInput {
  id: SortOrder
  login: SortOrder
  name: SortOrder
  group: SortOrder
  password: SortOrder
}

input UserUpdateInput {
  id: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  group: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  group: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: StringFilter
  login: StringFilter
  name: StringNullableFilter
  group: StringNullableFilter
  password: StringFilter
}

input UserWhereUniqueInput {
  id: String
  login: String
}
